
# item1 = 'Phone'  # <class 'str'>
# item1_price = 100  # <class 'int'>
# item1_quantity = 5  # <class 'int'>
# itrm1_priceTotal = item1_quantity * item1_price  # <class 'int'>
#? in datatypes we see the word 'class', that means these data types are instances of class 'string' or 'integer'

#? above things are just 4 variable of different data types

#TODO: Instance means objects

# class Item:
#     pass  # pass ie we are currently not adding here anyuthing

# item1 = Item() #creating an instance of a class


# #? the abovce thing is equivalent to creating a random variable, just like this line
# random_str = str('afg')



#! assign attributes to instanmces of class

# class Item:
#     pass  # pass ie we are currently not adding here anyuthing

# item1 = Item()
# item1.name = "phone"
# item1.price = 100
# item1.quantity = 5

# print(item1)
# # print(type(item1)) #item


#! create some methods and use them in our instances

#? 'self' parameter is autogenerated, that python wants us to receive intentionally. Reason: pyhton passes the object itself as a first argument, when you go ahead and call those methods. That is why we are not allow to pass arguments that will never receive parameters

# class Item:
#     def calculate_total_price(self, x, y):
#         return x * y


# item1 = Item()
# item1.name = "phone"
# item1.price = 100
# item1.quantity = 5
# print(item1.calculate_total_price(item1.price, item1.quantity))

# item2 = Item()
# item2.name = "laptop"
# item2.price = 1000
# item2.quantity = 3
# print(item2.calculate_total_price(item2.price, item2.quantity))

#? 'name' 'quantity' these are called attribute

#! now, we dont want to hard code the attributes(instance attribute): __init__

# class Item:
#     def __init__(self, name: str, price: float, quantity=0):
#         #Run validations to the received arguments
#         assert price >=0, f"Price {price} is not grater than or equal to zero!"
#         assert quantity >=0, f"Price {quantity} is not grater than or equal to zero!"

#         #Assign to self object
#         print(f"An instance created, Name: {name}, Price: {price}, Qt: {quantity}")
#         self.name = name
#         self.price = price
#         self.quantity = quantity

#     def calculate_total_price(self): #? we dont need to pass arguments here, cause they are already attributes in this class level
#         return (self.price * self.quantity)


# item1 = Item("Phone", 101, 6)
# print(item1.calculate_total_price())



# item2 = Item("Laptop", 1001, 4)
# # Python will automatically print the 

# #?adding more attributes to the instances
# item2.hasNumpad = False 



#! Class attribute: belnong to class level itself but you can also access the attribute from the instance level

# class Item:
#     pay_rate = 0.8 #pay rate after 20% discount in shop

#     def __init__(self, name: str, price: float, quantity=0):
#         #Run validations to the received arguments
#         assert price >=0, f"Price {price} is not grater than or equal to zero!"
#         assert quantity >=0, f"Price {quantity} is not grater than or equal to zero!"

#         #Assign to self object
#         print(f"An instance created, Name: {name}, Price: {price}, Qt: {quantity}")
#         self.name = name
#         self.price = price
#         self.quantity = quantity

#     def calculate_total_price(self):
#         return (self.price * self.quantity)


# item1 = Item("Phone", 100, 1)
# item2 = Item("Laptop", 1000, 3)

# print(Item.pay_rate) #0.8
# print(item1.pay_rate) #0.8
# print(item2.pay_rate) #0.8

#? So when we have an instance on our hand, then At first this instance tries to bring the attribute from the instance level at first stage, 
#? but if it doesn't find it there, then it is going to try to brting the attribute from class level

#!______________________________________________________________________________________________________________________________

# class Item:
#     pay_rate = 0.8 #pay rate after 20% discount

#     def __init__(self, name: str, price: float, quantity=0):
#         #Run validations to the received arguments
#         assert price >=0, f"Price {price} is not grater than or equal to zero!"
#         assert quantity >=0, f"Price {quantity} is not grater than or equal to zero!"

#         #Assign to self object
#         print(f"An instance created, Name: {name}, Price: {price}, Qt: {quantity}")
#         self.name = name
#         self.price = price
#         self.quantity = quantity

#     def calculate_total_price(self):
#         return (self.price * self.quantity)

#     def apply_discount(self):
#         self.price = self.price * self.pay_rate  #TODO: self.price will be altered when this function will be callled

# item1 = Item("Phone", 100, 1)

# item1.apply_discount()
# # print(item1.price)


# item2 = Item("Laptop", 1000, 3)
# item2.pay_rate = 0.7 #attribute altered at instance levelof item2
# item2.apply_discount()
# # print(item2.price)


#!______________________________________________________________________________________________________________________________
# class Item:
#     pay_rate = 0.8 #pay rate after 20% discount
#     all = []
#     def __init__(self, name: str, price: float, quantity=0):
#         #Run validations to the received arguments
#         assert price >=0, f"Price {price} is not grater than or equal to zero!"
#         assert quantity >=0, f"Price {quantity} is not grater than or equal to zero!"

#         #Assign to self object
#         print(f"An instance created, Name: {name}, Price: {price}, Qt: {quantity}")
#         self.name = name
#         self.price = price
#         self.quantity = quantity
        
#         #actions to execute
#         Item.all.append(self)

#     def calculate_total_price(self):
#         return (self.price * self.quantity)

#     def apply_discount(self):
#         self.price = self.price * self.pay_rate  #TODO: self.price will be altered when this function will be callled
#     #* __repr__
#     def __repr__(self):
#         # return "Item"
#         return f"Item('{self.name},{self.price},{self.quantity}')"

# item1 = Item("Phone", 100, 1)
# item2 = Item("Laptop", 1000, 3)
# item3 = Item("Cable", 10, 5)
# item4 = Item("Mouse", 50, 5)
# item5 = Item("Keyboard", 75, 5)

# print(Item.all) #? this will print all the instances/objects made from 'Item' class



#TODO: If you want to work with only of the instance of the class, then use for loop

# for instance in Item.all:
#     print(instance.name, instance.price)


#! Class vs Static Methods:
#? CSV: Comma Separated Value #look for a csv file

#! Inheritance:
